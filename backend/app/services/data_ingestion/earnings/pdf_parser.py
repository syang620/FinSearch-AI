"""
PDF Transcript Parser

Parses earnings call transcripts from PDF files.
"""

import logging
from pathlib import Path
from typing import Optional, Dict
import re

try:
    from pypdf import PdfReader
except ImportError:
    # Fallback to older PyPDF2 if pypdf not available
    from PyPDF2 import PdfReader

logger = logging.getLogger(__name__)


class PDFTranscriptParser:
    """Parser for earnings call transcript PDFs"""

    def parse_pdf(self, pdf_path: str) -> Optional[Dict]:
        """
        Parse PDF file and extract transcript text with speaker normalization
        and Q&A boundary detection

        Args:
            pdf_path: Path to PDF file

        Returns:
            Dictionary with transcript text, speakers, and metadata
        """
        pdf_file = Path(pdf_path)

        if not pdf_file.exists():
            logger.error(f"PDF file not found: {pdf_path}")
            return None

        logger.info(f"Parsing PDF: {pdf_file.name}")

        try:
            # Parse filename to get metadata
            metadata = self._parse_filename(pdf_file.name)

            if not metadata:
                logger.error(f"Could not parse filename: {pdf_file.name}")
                return None

            # Extract text from PDF
            text = self._extract_text_from_pdf(pdf_path)

            if not text:
                logger.error(f"No text extracted from PDF: {pdf_file.name}")
                return None

            # Clean the text
            cleaned_text = self._clean_text(text)

            # Detect Q&A boundaries
            qa_sections = self._detect_qa_boundaries(cleaned_text)

            # Extract and normalize speakers
            speakers = self._extract_speakers(cleaned_text)

            # Normalize speaker names in text
            normalized_text = self._normalize_speaker_names(cleaned_text, speakers)

            return {
                'ticker': metadata['ticker'],
                'year': metadata['year'],
                'quarter': metadata['quarter'],
                'transcript': normalized_text,
                'speakers': speakers,
                'qa_sections': qa_sections,
                'source_file': pdf_file.name,
                'source_path': str(pdf_file.absolute()),
                'file_size': pdf_file.stat().st_size,
            }

        except Exception as e:
            logger.error(f"Error parsing PDF {pdf_file.name}: {e}")
            import traceback
            traceback.print_exc()
            return None

    def _parse_filename(self, filename: str) -> Optional[Dict]:
        """
        Parse filename to extract ticker, year, quarter

        Expected format: {TICKER}_FY{year}_Q{quarter}.pdf
        Example: AAPL_FY2024_Q3.pdf
        """
        # Remove .pdf extension
        name = filename.replace('.pdf', '')

        # Pattern: TICKER_FY####_Q#
        pattern = r'^([A-Z.]+)_FY(\d{4})_Q([1-4])$'
        match = re.match(pattern, name)

        if match:
            ticker = match.group(1)
            year = int(match.group(2))
            quarter = int(match.group(3))

            return {
                'ticker': ticker,
                'year': year,
                'quarter': quarter
            }

        logger.warning(f"Filename doesn't match expected pattern: {filename}")
        return None

    def _extract_text_from_pdf(self, pdf_path: str) -> Optional[str]:
        """
        Extract all text from PDF

        Args:
            pdf_path: Path to PDF file

        Returns:
            Extracted text or None if failed
        """
        try:
            reader = PdfReader(pdf_path)

            text_parts = []
            for page_num, page in enumerate(reader.pages, 1):
                try:
                    text = page.extract_text()
                    if text:
                        text_parts.append(text)
                except Exception as e:
                    logger.warning(f"Error extracting page {page_num}: {e}")
                    continue

            if not text_parts:
                return None

            return '\n\n'.join(text_parts)

        except Exception as e:
            logger.error(f"Error reading PDF: {e}")
            return None

    def _clean_text(self, text: str) -> str:
        """
        Clean and normalize extracted text

        Args:
            text: Raw extracted text

        Returns:
            Cleaned text
        """
        # Remove boilerplate headers (e.g., "Generated by discountingcashflows.com")
        boilerplate_patterns = [
            r'Generated by discountingcashflows\.com\s*\n',
            r'Date:.*?\d{4}\s*\n',
            r'\w+ Earnings Call â€“ FY\d{4} Q\d\s*\n',
        ]

        for pattern in boilerplate_patterns:
            text = re.sub(pattern, '', text, flags=re.IGNORECASE)

        # Remove excessive whitespace
        text = re.sub(r'\n\s*\n', '\n\n', text)

        # Remove page numbers (common pattern: just a number on a line)
        text = re.sub(r'\n\d+\n', '\n', text)

        # Normalize line breaks
        text = text.replace('\r\n', '\n')
        text = text.replace('\r', '\n')

        # Remove leading/trailing whitespace
        text = text.strip()

        return text

    def _extract_speakers(self, text: str) -> Dict[str, str]:
        """
        Extract and identify speakers from transcript

        Returns:
            Dictionary mapping original names to normalized names
        """
        speakers = {}

        # Pattern for speaker names (name at start of line, usually followed by speech)
        # Common patterns: "John Smith\nHello..." or "John Smith, CEO\nHello..."
        speaker_pattern = r'^([A-Z][a-z]+(?: [A-Z][a-z]+)+)(?:,.*?)?\n'

        matches = re.finditer(speaker_pattern, text, re.MULTILINE)

        for match in matches:
            original_name = match.group(1).strip()

            # Normalize: Remove titles, keep first and last name
            normalized_name = self._normalize_name(original_name)

            if original_name not in speakers:
                speakers[original_name] = normalized_name
                logger.debug(f"Found speaker: {original_name} -> {normalized_name}")

        return speakers

    def _normalize_name(self, name: str) -> str:
        """Normalize a person's name by removing titles and standardizing format"""
        # Remove common titles
        titles = ['Mr.', 'Mrs.', 'Ms.', 'Dr.', 'Prof.', 'CEO', 'CFO', 'CTO', 'COO',
                  'Director', 'VP', 'Vice President', 'President', 'Chairman']

        normalized = name
        for title in titles:
            normalized = normalized.replace(title, '').strip()

        # Clean up extra spaces
        normalized = re.sub(r'\s+', ' ', normalized)

        return normalized.strip()

    def _normalize_speaker_names(self, text: str, speakers: Dict[str, str]) -> str:
        """
        Normalize speaker names in the transcript text

        Args:
            text: Original transcript text
            speakers: Dictionary mapping original to normalized names

        Returns:
            Text with normalized speaker names
        """
        normalized_text = text

        for original, normalized in speakers.items():
            # Replace speaker name at beginning of lines
            pattern = r'^' + re.escape(original) + r'(?=\n)'
            normalized_text = re.sub(
                pattern,
                f'[SPEAKER: {normalized}]',
                normalized_text,
                flags=re.MULTILINE
            )

        return normalized_text

    def _detect_qa_boundaries(self, text: str) -> Dict[str, int]:
        """
        Detect boundaries between presentation and Q&A sections

        Returns:
            Dictionary with section markers and their positions
        """
        sections = {}

        # Common Q&A section markers
        qa_patterns = [
            (r'(?:Question|Q)[ -]?(?:and|&)[ -]?(?:Answer|A)', 'qa_start'),
            (r'(?:Operator|Moderator)\s*\n', 'qa_start'),
            (r'(?:questions? (?:and )?answers?)', 'qa_start'),
            (r'(?:open(?:ing)? (?:the )?call (?:to|for) questions)', 'qa_start'),
        ]

        for pattern, section_type in qa_patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                sections[section_type] = match.start()
                logger.debug(f"Found {section_type} at position {match.start()}")
                break  # Use first match only

        # If Q&A section found, mark presentation section
        if 'qa_start' in sections:
            sections['presentation_end'] = sections['qa_start']
            sections['presentation_start'] = 0

        return sections


# Global parser instance
pdf_parser = PDFTranscriptParser()
